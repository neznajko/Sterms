#! /usr/bin/env python3
# coding = utf-8
#[40]###################################
C, D, S = b"()S"           # uess typing
#[72]###################################################################
import sys
#[64]###########################################################
#
# V. *** S-TERMS PROBLEM (Selected for the 2nd round)
####################################################[56]
# An s-term is a sequence of S's and parentheses defined
# recursively as follows:
#
# S is an s-term, and if M and N are s-terms, (MN) is
# also an s-term.
#
# Example of an s-term: ((((SS)(SS))S)(SS))
#
# The right parentheses provide no new information, so
# they can be omitted, i.e. (MN instead of (MN), so
# that the previous s-term becomes: ((((SS(SSS(SS
############################################################################[80]
# 1. Write a procedure 'gensterm' to generate s-terms: your procedure should
# generate n (n=length=number of S's) textfiles containing all s-terms of length
# 1,...,n respectively. S-terms should be separated by ";". The end of the last
# s-term in each file should be marked with ".".
####################################################[56]
# Write a program that accepts an integer n(<=10), uses
# the above procedure and displays all generated s-terms
# on the screen.
############################################################[64]
# Consider a calculus with s-terms. The only algebraic rule
# (s-rule) that can be used is the following: any subterm of an
# s-term that has the form (((SA)B)C) (where A,B and C are
# s-terms) can be rewritten as: ((AC)(BC)) i.e.
#
# Context1(((SA)B)C)Context2->Context1((AC)(BC))Context2
#
# The application of this rule on an s-term is called
# 'reduction' of the s-term.
#
# There are different ways (strategies) of choosing a subterm to
# apply the s-rule. The succesive application of the s-rule on
# an s-term until no more applications of the s-rule are
# possible is called 'normalization' of the sterm.
#
# Example of a reduction chain:
#
# ((((SS)(SS))S)(SS))       ->
# (((SS)((SS)S))(SS))       ->
# ((S(SS))(((SS)S)(SS)))    ->
# ((S(SS))((S(SS))(S(SS))))
#
####################################################################[72]
# 2. Choose an appropriate data structure for representing s-terms which
# can facilitate the application of the s-rule. Write two procedures
# 'readterm' and 'printterm' that transform s-terms to (and from) your
# representation from (and to) the form generated by 'gensterm'. Your
# program should be able to demonstrate these transformations.
############################################################[64]
# 3. Write a procedure 'reduce' to perform one reduction step
# according to the s-rule on a specified subterm of an s-term
# given in yout representation. Your program should be able to
# demonstrate this.
############################################################[64]
# 4. Write a procedure 'normalize': given an s-term, it should
# repeatedly choose a subterm to apply the s-rule, until no
# further reducations are possible or until the number of
# reduction steps exceeds some maximum, e.g. 30. Your program
# should be able to demonstrate this.
####################################################[56]
# 5. Finally, incorporate all of the above in a program
# that:
#  a) requests a length n from the user, 
#  b) uses s-terms of length n, generated by 'gensterm',
#  c) transforms s-terms into your representation,
#  d) normalizes (if possible),
#  e) outputs the resulting (normalized) s-terms,
#  f) outputs the number of reduction steps performed
# for each s-term, or a 'not normalized' message in case
# of unsuccessful normalization in 30 steps, and
#  g) outputs the number of not normalized vs. the total
# number of s-terms for the given length n.
#
#[80]########################################################### S-TERMS PROBLEM
#
# Ok, the most normal approach will be similar to generating Fibonacci numbers;
# by induction to generate all s-terms of length n we need all s-terms of
# length [1:n-1]. The time is incresing super fast with n probably exponentialy,
# and for n >= 17 it starts running forever, so I've decided it's the right time
# to learn a new algorithm. Algorithm P will generate all nested parenthesis
# and there is a one to one correspondence of s-terms with them:
# (S(SS))    <=> (S(SS   <=> ()()
# ((SS)(SS)) <=> ((SS(SS <=> (())()
# The function convýort will convÿort 3rd represenation to 2nd, it represents
# a binary tree in inoreder for example ((SS(SS is:
#         here S-nodes are leafs, meaning all children nodes are terminal nodes.
#    (    
#           
#  (   (
# S S S S 
#
#[64]###########################################################
# Knuth4A.pdf
# 7.2.1.6                                   GENERATING ALL TREES
# Algorithm P (Nested parenthesis in lexicographical order).
# Given n >= 2 this one will generate all a[1:2n] parenthesis.
# P1. [Initialize.] for 1 <= k <= n set a[2k - 1] to '(', a[2k]
#     to ')' and a[0] to ')' as well, set m to 2n - 1.
# P2. [Visit.] Visit a, at this point a[m] is the last '('.
# P3. [Easy case?] a[m] <- ')' iif a[m - 1] == ')', set a[m - 1]
#     to '(', m <- m - 1 and go back to P2.
# P4. [Find j.] Set j to m - 1, and k to 2n - 1. While a[j] is
#     '(', set a[j] to ')', a[k] to '(', j <- j - 1, k <- k - 2.
# P5. [Increase a[j].] If j = 0 terminate. Set a[j] to '(',
#     m to 2n - 1 and go back to P2.
#[64]############################################### [style 1.2]
#[32]###########################
def algoritPm(n):              #
                               # [ P1. Initialize. ]
    ls = []                    # s-terms list
    l = n << 1                 # 2n
    a = bytearray()            # parenthesis array
    for j in range(l + 1):     # [0, 2n]
        i = j & 1              # even/odd bit
        a.append(b")("[i])     # yeah!
    m = l - 1                  # 2n - 1
    while True:                # loofing
                               # [ P2. Visit. ]
        ls.append(a[1:][:])    # copy
                               # [ P3. Easy Case? ]
        a[m] = D               # a[m] was (
        j = m - 1              # set j here
        if a[j] == D:          # ))
            m = j              # :)
            a[m] = C           # ()
            continue           # to P2
                               # [ P4. Find j. ]
        k = l - 1              # 2n - 1
        while a[j] == C:       # at first entry a[j] is (
            a[j] = D           # reverse to )
            a[k] = C           # reverse to (
            j -= 1             # :)
            k -= 2             # why?
                               # [ P5. Increase a[j]. ]
        if j == 0: break       # ve ar don!
        a[j] = C               # (
        m = l - 1              # 2n - 1 and go back to P2
    return ls                  # et voilà
#[--]################################################# algoritPm
#[40]###################################
# Convyort nested parenthesis array to
# s-term.
#[32]###########################
def convýort(p):               #
    for j in range(len(p)):    #
        if p[j] == D: p[j] = S #
    p.append(S)                #
#[..]########################## convýort
#[56]###################################################
def gen_sterm(n):
    if n == 1: return [bytearray(b'S')]
    if n == 2: return [bytearray(b'(SS')]
    ls = algoritPm(n - 1)
    for i in range(len(ls)): convýort(ls[i])
    return ls
#['']######################################### gen_sterm
#[80]###########################################################################
# Write </n> s-term-filez in an existing directory </offput> named s-term-</n>..
def write_sterm ( n ) : #                                           [style 3.14]
    path = "./offput"
    for j in range ( 1 , n + 1 ) :
        ls = gen_sterm ( j )
        print ( len ( ls ) )
        fnom = f'{ path }/s-term-{ j }'
        print ( fnom )
        with open ( fnom , 'w' ) as f :
            print ( con_sterm ( ls ) )
            f . write ( con_sterm ( ls , sep = ';' ) + '.' )
#[,,]############################################################### write_sterm
#[64]###########################################################
# Get the sterm starting from position </i> at byte array </a>.
# Return the positon of the next element or -1 if not found.
#[24]################### e.g.: (((SSSS
def get_sterm(a, i):   #         ^ 
    n = 0              # dec on ( inc on S, stop if eq to 1
    for j in range(i, len(a)):
        if a[j] == C:  #
            n -= 1     #
        else:          #
            n += 1     #
        if n == 1:     #
            return j + 1
    return -1          #
#[##]################################################# get_sterm
#[56]###############################################"###
def con_sterm(ls, sep='\n'):
    """"""""""""""""""""""""""""""""""""""""""""""""#"""
    return sep.join([x.decode("utf-8") for x in ls])
#[**]######################################### con_sterm
#[64]###########################################################
#[32]########################### e.g.: ((((SS(SSS(SS
def find_srule(a, i):          #        ----
    """ Find the beginning of an s-rule starting from </i>. """
    return a[i:].find(b'(((S') # -1 if not found.
#['']################################################ find_srule
#[32]########################### e.g.: ((((SS(SSS(SS
def parse_srule(a, i):         #        _   ABBBC
    i += 4                     # Ok! we start from here.
    ABC = []                   #
    for cx in range(3):        #
        j = get_sterm(a, i)    #
        if j == -1: break      #
        ABC.append(a[i:j])     #
        i = j                  #
    return ABC                 # On success len(ABC) is 3.
####################[##]############################ parse_srule
#[64]###########################################################
def sumlen(ls): return sum(map(lambda x: len(x), ls))
def srule(A,B,C): return b'((' + A + C + b'(' + B + C
#[32]###########################
def reduce(a):                 # 
    i = find_srule(a, 0)       #
    if i == -1: return False   # fölz
    ABC = parse_srule(a, i)    #
    if len(ABC) < 3: return False
    j = i + 4 + sumlen(ABC)    #
    a[:] = a[:i] + srule(*ABC) + a[j:]
    return True                #
##################[##]################################### reduce
#[40]###################################
def normalize(a):
    ls = []
    while reduce(a) and len(ls) < 30:
        ls.append(a[:])
    return ls
###################[##]####### normalize
#[80]############# To run the program with n=10 and mode=2 type ./Sterms.py 10 2
#mode#1#will#run#point#1,#mode#2#point#5########################################
def geropt():
    args = [5, 1] # n, mode
    for c, v in enumerate(sys.argv[1:]):
        args[c] = int(v)
    return args
####################################[##]################################# geropt
#[64]###########################################################
def mode2(n):
    ls = gen_sterm(n)
    deviant = 0
    for a in ls:
        norm = normalize(a[:])
        l = len(norm)
        if l == 0: deviant += 1
        print(a.decode("utf-8"), l, con_sterm(norm, sep=" "))
    print("deviant/total: {}/{}".format(deviant, len(ls)))    
####################################[##]################## mode2
if __name__ == '__main__':
    n, mode = geropt()
    print("n={}, mode={}".format(n, mode))
    if mode == 1:
        write_sterm(n)
    else:
        mode2(n)
#############[##]########################################################## log:
# cure:
# next:
